# 복잡도 정리
## 📌 복잡도의 종류

알고리즘 성능을 분석할 때 주로 두 가지 복잡도를 고려한다.

1. **시간 복잡도(Time Complexity)**: 실행 속도에 영향을 미침  
2. **공간 복잡도(Space Complexity)**: 사용하는 메모리 크기에 영향을 미침  

이 문서에서는 주로 **시간 복잡도**를 기준으로 정리하며, 필요한 경우 공간 복잡도도 함께 고려한다.

### 🧠 시간 복잡도는 왜 중요할까?

코딩 테스트를 처음 시작하면 가장 어렵게 느껴지는 개념 중 하나가 바로 **시간 제한**이다.  
"이 코드, 시간 안에 돌아갈까?"라는 걱정이 꼬리를 물게 된다.

이때 중요한 도구가 바로 **시간 복잡도(Time Complexity)** 개념이다.  
이는 **코드가 얼마나 빠르게 실행되는지를 분석하는 기준**이 된다.

시간 복잡도를 표현할 때는 **빅오(Big-O) 표기법**을 사용한다.  
이는 입력 크기(N)가 커질수록 실행 시간이 얼마나 빨리 증가하는지를  
"빠르게 증가하는 항만 고려해서" 단순화한 방식이다.

예를 들어 `O(n^2 + n)`이라는 복잡도가 있을 때,  
N이 커지면 결국 `n^2`이 지배적인 항이 되므로 `O(n^2)`로 표현한다.

## 코딩 테스트에서 시간 제한을 이해하는 법

- 일반적으로 **1초에 약 1억 번 연산 가능**  
- 문제마다 제한 시간은 **1~5초**가 주어지며,  
  **주어진 N의 크기에 따라 적절한 알고리즘 시간 복잡도**를 선택해야 함

---

## 📌 시간 복잡도별 최대 수행 가능 연산 수 (1초 기준)

| 시간 복잡도 | 최대 입력 크기 추정 | 설명 |
|-------------|---------------------|------|
| O(N)        | 약 100,000,000      | 선형 탐색, 단순 순회 |
| O(N^2)      | 약 10,000           | 이중 루프, 브루트포스 |
| O(N^3)      | 약 500              | 3중 루프 |
| O(2^N)      | 약 20               | 재귀 완전탐색 |
| O(N!)       | 약 10               | 순열/조합 전수 탐색 |

---

## ✅ N 크기별 시간 복잡도 선택 기준

| N의 최대값     | 선택 가능한 알고리즘 복잡도 |
|----------------|------------------------------|
| 500            | O(N³) 이하                   |
| 2,000          | O(N²) 이하                   |
| 100,000        | O(NlogN) 이하                |
| 10,000,000     | O(N) 이하                    |
| 10,000,000,000 | O(logN) 이하                 |

---

## 🛠 실전 팁: 탐색 속도를 올리는 방법

### ❗️ 문제 상황
배열 내에서 값을 여러 번 `contains()`로 찾으면 → O(n × q)

### ✅ 해결 전략
- 배열을 처음 한 번 `Set` 또는 `Dictionary`로 변환 (O(n))  
- 이후 탐색은 O(1) 수준으로 빠르게 가능

```swift
let arr = [1, 2, 3, 4, 5]
let set = Set(arr)
set.contains(3) // → O(1)
```

| 탐색 방식           | 시간 복잡도 | 비고 |
|---------------------|--------------|------|
| `array.contains(x)` | O(n)         | 반복 탐색 시 느림 |
| `set.contains(x)`   | O(1)         | 탐색 최적화 가능 |

---

## 🔍 자주 쓰는 연산의 시간 복잡도 정리

| 연산 또는 함수 | 시간 복잡도 | 설명 |
|----------------|--------------|------|
| `for` loop     | O(n)         | 단순 순회 |
| 이중 `for` loop | O(n²)        | 완전 탐색 |
| `array.contains()` | O(n)     | 배열 탐색 |
| `set.contains()`   | O(1)     | 해시 기반 탐색 |
| `dictionary[key]`  | O(1)     | 키-값 조회 |
| `sort()`           | O(n log n) | Swift 기본 정렬 |
| `binary search`    | O(log n) | 정렬 배열 탐색 |
| `heap.pop()`       | O(log n) | 우선순위 큐 |
| `stack.pop()` / `queue.pop()` | O(1) | 선형 자료구조 |

---

## ✅ 결론

- **연산 횟수 ≒ 시간 복잡도 × 입력 크기**
- 문제에서 **N을 보면** → **가능한 시간 복잡도를 역으로 추정**
- `Set`, `Dictionary`, 정렬, 이진탐색, 힙 등 자료구조와 알고리즘 활용으로 속도를 최적화할 수 있다



## History
- 250329 : 초안작성
