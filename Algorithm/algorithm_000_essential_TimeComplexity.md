# 복잡도 정리

## 📌 시간복잡도의 개념 도입

알고리즘 성능을 분석할 때 주로 두 가지 복잡도를 고려한다.

1. **시간 복잡도(Time Complexity)**: 실행 속도에 영향을 미침  
2. **공간 복잡도(Space Complexity)**: 사용하는 메모리 크기에 영향을 미침  

이 문서에서는 주로 **시간 복잡도**를 기준으로 정리하며, 필요한 경우 공간 복잡도도 함께 고려한다.

### 🧠 시간 복잡도는 왜 중요할까?

코딩 테스트를 처음 시작하면 가장 어렵게 느껴지는 개념 중 하나가 바로 **시간 제한**이다.  
"이 코드, 시간 안에 돌아갈까?"라는 걱정이 꼬리를 물게 된다.

이때 중요한 도구가 바로 **시간 복잡도(Time Complexity)** 개념이다.  
이는 **코드가 얼마나 빠르게 실행되는지를 분석하는 기준**이 된다.

시간 복잡도를 표현할 때는 **빅오(Big-O) 표기법**을 사용한다.  
이는 입력 크기(N)가 커질수록 실행 시간이 얼마나 빨리 증가하는지를  
"빠르게 증가하는 항만 고려해서" 단순화한 방식이다.

예를 들어 `O(n^2 + n)`이라는 복잡도가 있을 때,  
N이 커지면 결국 `n^2`이 지배적인 항이 되므로 `O(n^2)`로 표현한다.

<br><br>


### 📘 예시로 보는 시간 복잡도: O(1)

이번에는 매우 간단한 코드로 시간 복잡도 `O(1)`의 개념을 살펴보자.

```swift
let a = 5
let b = 7
print(a + b)
```

이 코드에서는 단순히 두 수를 더하는 연산만 한 번 수행된다.  
즉, 입력의 크기(N)와 상관없이 **항상 일정한 시간** 내에 실행되는 연산이다.

물론 `let`을 통한 대입이나 `print()` 함수 호출도 있지만,  
**시간 복잡도를 분석할 때는 가장 영향력이 큰 연산만 고려**하기 때문에,  
이 코드는 **상수 시간 연산**, 즉 `O(1)`이라고 표현한다.


<br><br>

### 📘 예시로 보는 시간 복잡도: O(N)

아래는 배열의 합을 구하는 간단한 예제이다.

```swift
let array = [3, 5, 1, 2, 4]
var summary = 0

for i in array {
    summary += i
}

print(summary)
```

이 코드에서는 배열에 있는 5개의 데이터를 차례로 한 번씩 더해주고 있다.  
즉, `N = 5`인 경우 총 5회의 덧셈 연산이 발생한다.

이런 식으로, 연산 횟수가 입력 크기 `N`에 **정비례**하는 경우,  
시간 복잡도는 `O(N)`이라고 표현한다.

물론 실제 코드에는 `summary += i`처럼 대입 연산도 있고, `print(summary)`처럼 출력하는 부분도 있지만,  
**입력 크기 `N`이 커질수록 영향력이 미미해지기 때문에**,  
우리는 **가장 영향력이 큰 항만 고려**하여 `O(N)`이라고 표기한다.


<br><br>

### 📘 예시로 보는 시간 복잡도: O(N²)

다음은 이중 반복문을 사용하는 예제이다.

```swift
let array = [3, 5, 1, 2, 4]
for i in array {
    for j in array {
        let temp = i * j
        print(temp)
    }
}
```

이 코드에서는 배열의 모든 원소를 서로 곱한 값을 출력한다.  
바깥 루프와 안쪽 루프가 각각 N번 반복되므로,  
전체 연산 횟수는 `N * N = N²`이 되어 **시간 복잡도는 O(N²)** 이다.

단, **모든 이중 반복문이 항상 O(N²)** 인 것은 아니다.  
반복문 내부에서 호출되는 함수의 시간 복잡도나 반복 조건에 따라  
전체 복잡도는 달라질 수 있다.  
→ 따라서 **정확한 시간 복잡도 계산을 위해서는 코드 전체의 구조를 분석**해야 한다.

또한 퀵 정렬(Quick Sort)은 평균적으로는 `O(NlogN)`의 성능을 보이지만,  
**최악의 경우에는 O(N²)**의 시간 복잡도가 발생할 수 있다.

👉 **코딩 테스트에서는 "최악의 경우"를 기준으로 연산 횟수를 판단**해야 하므로,  
항상 **최악의 시간 복잡도**를 염두에 두는 습관이 중요하다.

<br><br>


## 📌 시간 복잡도별 명칭

아래는 자주 등장하는 시간 복잡도를 빠른 순서대로 정리한 표이다.

| 빅오 표기법 | 명칭        |
|:------------|:------------|
| O(1)        | 상수 시간   |
| O(logN)     | 로그 시간   |
| O(N)        | 선형 시간   |
| O(NlogN)    | 로그 선형 시간 |
| O(N²)       | 이차 시간   |
| O(N³)       | 삼차 시간   |
| O(2^N)      | 지수 시간   |

## 📊 N 크기에 따른 연산 횟수 비교

|  빅오 표기법 | N이 1000일때의 연산횟수        |
|:------------|------------:|
| O(N)        | 1,000    |
| O(NlogN)    | 10,000   |
| O(N²)       | 1,000,000   |
| O(N³)       | 1,000,000,000   |


<br><br>

## 📌 코딩 테스트 환경에서의 시간 제한과 N별 알고리즘 전략

✅ 따라서 코딩 테스트에서는 시간 복잡도가 `O(N³)`을 넘는다면,  
**입력 크기(N)를 반드시 확인하고** 다른 방법(메모이제이션, DP, 자료구조 등)을 고려해야 한다.

👉 시간 제한이 **1~5초**인 코딩 테스트 환경에서는  
**10억 회 연산을 넘는 로직은 오답 판정을 받을 가능성이 높다.**

<br><br>

## 🛠 탐색 최적화 전략 (Set, Dictionary 등)

### ❗️ 문제 상황
배열 내에서 값을 여러 번 `contains()`로 찾으면 → O(n × q)

### ✅ 해결 전략
- 배열을 처음 한 번 `Set` 또는 `Dictionary`로 변환 (O(n))  
- 이후 탐색은 O(1) 수준으로 빠르게 가능

```swift
let arr = [1, 2, 3, 4, 5]
let set = Set(arr)
set.contains(3) // → O(1)
```

| 탐색 방식           | 시간 복잡도 | 비고 |
|---------------------|--------------|------|
| `array.contains(x)` | O(n)         | 반복 탐색 시 느림 |
| `set.contains(x)`   | O(1)         | 탐색 최적화 가능 |

## 🔍 자주 쓰는 연산별 시간 복잡도 정리

| 연산 또는 함수 | 시간 복잡도 | 설명 |
|----------------|--------------|------|
| `for` loop     | O(N)         | 단순 순회 |
| 이중 `for` loop | O(N²)        | 완전 탐색 |
| `array.contains()` | O(N)     | 배열 탐색 |
| `set.contains()`   | O(1)     | 해시 기반 탐색 |
| `dictionary[key]`  | O(1)     | 키-값 조회 |
| `sort()`           | O(N log N) | Swift 기본 정렬 |
| `binary search`    | O(log N) | 정렬 배열 탐색 |
| `heap.pop()`       | O(log N) | 우선순위 큐 |
| `stack.pop()` / `queue.pop()` | O(1) | 선형 자료구조 |

## ✅ 결론

- **연산 횟수 ≒ 시간 복잡도 × 입력 크기**
- 문제에서 **N을 보면** → **가능한 시간 복잡도를 역으로 추정**
- `Set`, `Dictionary`, 정렬, 이진탐색, 힙 등 자료구조와 알고리즘 활용으로 속도를 최적화할 수 있다

## History
- 250329 : 초안작성
- 250330 : 시간복잡도의 기초 추가
