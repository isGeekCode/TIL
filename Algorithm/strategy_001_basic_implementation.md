# 기본 문제 해결 - 구현(Implementation)

코딩 테스트에서 구현이란, **머릿속에 있는 알고리즘을 실제 소스코드로 바꾸는 과정**을 말한다.  

어떤 문제를 풀든 결국 코드를 작성해야 하므로, 구현은 **모든 알고리즘 문제에 포함된 공통 요소**이기도 하다.

이런 이유로 대부분의 알고리즘 교재에서는 구현을 별도의 유형으로 다루지 않는다.  
하지만 실제 취업 코딩 테스트에서는 **구현 자체가 중심이 되는 문제**들이 자주 출제되며,  
종종 단순한 조건 구현과 시뮬레이션이 더 어렵게 느껴지기도 한다.

👉 따라서 다른 알고리즘보다도 먼저 '구현 감각'을 익히는 것이 훨씬 실용적이며 중요하다.


알고리즘 문제를 해결할 때, 우리는 먼저 문제를 읽고 풀이 방법을 고민한다.  
충분히 고민한 끝에 문제에 대한 정확한 해결 아이디어가 떠올랐다고 해도,  
그것만으로 정답을 받을 수 있는 것은 아니다.

생각한 풀이 방법을 **우리가 사용하는 언어로 정확하게 구현**했을 때,  
비로소 정답 판정을 받을 수 있다.

→ Problem → Thinking → Solution → Code

이를 위해서는 프로그래밍 언어의 문법을 잘 알고 있어야 하며,  
문제의 요구사항에 어긋나지 않는 방식으로 **실수 없이 코드를 작성**해야 한다.

흔히 문제 해결 분야에서 구현 유형의 문제는 **풀이 아이디어는 떠올리기 쉬우나, 실제 소스코드로 옮기기 어려운 문제**를 의미한다.  
그래서 알고리즘을 설계하고도 손이 안 가는 경우, 대회 경험이 많은 사람들은 “이럴 땐 먼저 구현 문제부터 푸는 게 좋다”고 조언하기도 한다.

개발 실무에서도 **언어 문법에 능숙하고 코드 작성 속도가 빠른 사람**을 두고 ‘피지컬이 좋다’고 말한다.  
구현 문제는 그런 의미에서 **프로그래밍 피지컬**을 요구하는 문제라고 볼 수 있다.

예를 들어 알고리즘 문제 풀이를 전략 시뮬레이션 게임에 비유해 보자.  
스타크래프트에서 완벽한 전략을 세웠다고 해도, 마우스와 키보드 컨트롤이 전략을 따라가지 못하면 이기기 어렵다.  
구현 문제도 마찬가지다. 전략(아이디어)을 세우는 것도 중요하지만, 그것을 빠르고 정확하게 실현하는 능력이 필요하다.

그렇다면 어떤 문제가 구현하기 어려운 문제일까?

- 알고리즘은 간단하지만 코드가 **지나치게 길어지는 문제**
- **소수점 자릿수**를 정확히 맞춰 출력해야 하는 문제
- **문자열 파싱**이 복잡한 문제 (ex. 한 글자 단위로 쪼개야 하는 경우)
- **조건 분기**가 지나치게 많아 구현 자체가 피곤한 문제

이러한 문제들은 초보자에게 특히 까다롭게 느껴질 수 있다.  
물론 경험 많은 사람에겐 단순 반복이겠지만, **언어 자체에 익숙하지 않다면 구현만으로도 큰 장벽**이 될 수 있다.

그래서 실제로 코딩 테스트에서 구현 문제를 만나면 당황할 수 있다.  
어떻게 풀면 될지 감은 오는데, 막상 **코드로 옮기려 하다 보면 어떻게 작성해야 할지 모를 수 있기 때문이다.**

특히 **문법이나 라이브러리 사용 경험이 부족하면 구현 유형의 문제에서 불리**하다.  
예를 들어 N개의 원소가 들어있는 리스트에서 R개의 원소를 뽑아 한 줄로 나열하는 모든 경우(순열)를 구해야 하는 문제가 있다고 하자.  
무작정 순열을 구현할 수도 있지만, 파이썬의 `itertools.permutations()` 같은 표준 라이브러리를 쓰면 매우 간단하게 해결할 수 있다.

Swift에서는 `Array`의 `permutations()`는 기본으로 제공되진 않아
로직을 직접 구현하거나, 커뮤니티에서 제공하는 순열 유틸을 활용할 수 있다.  
Swift Algorithms 패키지를 사용할 경우, `permutations(ofCount:)`와 같은 메서드도 존재한다.

이러한 해결 방법은 **언어의 문법을 깊이 이해하고 다양한 구현 경험이 있을 때** 바로 떠올릴 수 있다.

## 구현과 연관된 문제 유형: 완전탐색 & 시뮬레이션

구현 유형은 **완전탐색**과 **시뮬레이션** 문제 유형과 함께 다뤄지는 경우가 많다.

- **완전탐색**은 모든 경우의 수를 **빠짐없이 전부 시도해보는 방식**으로, 정답을 보장할 수 있는 전형적인 구현 전략이다.
- **시뮬레이션**은 문제에서 주어진 알고리즘 또는 규칙을 **차례대로 단계별로 따라가며 구현**해야 하는 문제 유형이다.

두 유형 모두 아이디어 자체는 명확하지만, **직접 구현해내는 능력**이 정답의 핵심이 되기 때문에  
구현력을 키우는 데 매우 중요한 실전 연습 대상이다.

## 🛠 구현 문제에 접근하기

보통 구현 유형의 문제는 사소한 입력 조건 등이 문제에 명시되며, **문제 설명 길이도 꽤 긴 편**이다.  
이런 이유로 문제의 분량만 보고 지레 겁먹기 쉽지만, **고차원적인 알고리즘 사고를 요하지 않는 경우가 많기 때문에**  
문법에 익숙하다면 오히려 쉽게 풀 수 있는 유형이기도 하다.

특히 C/C++에서는 구현 문제가 상대적으로 더 어렵게 다가올 수 있다.  
문자열 처리가 번거롭고, 큰 정수(BigInt) 처리를 위해 별도의 라이브러리를 써야 하는 경우가 많기 때문이다.  
반면 파이썬은 기본 문법만 알아도 간단한 구현 문제는 비교적 쉽게 해결할 수 있다.

구현 유형 문제에서는 **언어 선택**에 따라 접근 난이도가 달라질 수 있다는 점도 고려하자.
다음은 구현 알고리즘의 대표적인 예시인 **상하좌우** 문제다.

---

## 🚶 구현 예제 1 - 상하좌우

**문제 설명**

여행가 A는 N x N 크기의 정사각형 공간 위에 서 있다.  
공간은 1 x 1 크기의 정사각형으로 나뉘어 있으며, 좌측 상단은 (1,1), 우측 하단은 (N,N) 좌표에 해당한다.  
A는 상하좌우 방향으로 이동할 수 있고, **시작 좌표는 항상 (1,1)**이다.

계획서에는 `L`, `R`, `U`, `D` 중 하나의 문자가 공백으로 구분되어 반복적으로 주어진다.

| 기호 | 의미          |
|------|---------------|
| L    | 왼쪽으로 한 칸 |
| R    | 오른쪽으로 한 칸 |
| U    | 위로 한 칸     |
| D    | 아래로 한 칸   |

단, A가 공간을 벗어나는 움직임은 **무시**된다.  
예를 들어 (1,1) 위치에서 `L`이나 `U`를 입력받으면 무시된다.

### 입력 조건

- 첫째 줄에 공간의 크기 N이 주어진다. (1 ≤ N ≤ 100)
- 둘째 줄에 A가 이동할 계획서가 공백을 기준으로 주어진다.  
  (이동 횟수는 1 이상 100 이하이며, L, R, U, D 중 하나의 문자가 공백으로 구분되어 주어진다)

### 출력 조건

- 여행가 A가 최종 도착한 지점의 좌표를 공백으로 구분하여 출력한다.  
  예: `3 4`

### 이동 과정

- (1,1) → (1,2) → (1,3) → (1,4) → (1,4) → (2,4) → (3,4)

### 접근 방식

- 방향에 따른 `dx`, `dy`를 정해놓고  
- 명령어를 읽을 때마다 다음 위치를 계산한 후,  
- 범위를 벗어나는 경우는 무시하고 아닌 경우만 위치 갱신

이 문제는 좌표 계산 + 조건 분기 + 경계처리를 요구하는 대표적인 **시뮬레이션 기반 구현 문제**이다.

### 💬 말코딩으로 살펴보는 구현 흐름

```swift
// - dx, dy 배열과 매핑된 움직임 타입을 정의한다. (여행계획서와 - 매칭되는 값으로)
// - plans를 " " 기준으로 분리하여 배열생성한다. planList
// - planList를 순회하면서 plan을 꺼낸다
// - plan이 moveTypes 중에 일치하는 게있으면 그 인덱스 구하기
// - 범위를 벗어나는 지 체크
//   - nx >= 1 && ny >=1 && nx<=n && ny <= n
//   - 조건 허용시 x와 y에 부여jㅇ해
// - 포문을 다돌고 x y 를 띄어쓰기 기준으로 생성해서 리턴 "\(x) \(y)"
```
이미 방문한 위치를 기록해두고 다시 방문하지 않도록 해야 하는 경우 지도와 동일한 크기의 이차원배열을 생성해야한다 visited[x][y] 

### ✍️ 직접 구현한 풀이의 시간 복잡도 검토

문제 해결을 위한 본인의 로직을 시간 복잡도 기준으로 검토해보면 다음과 같다:

- 명령 문자열을 공백으로 나누는 split: O(K)  
  (K는 문자열 길이이며, 최대 100자 수준이므로 상수로 취급 가능)
- 분리된 명령어 리스트(planList)를 for문으로 순회: O(N)  
  (N은 명령어 수, 최대 100)
- 각 명령어 처리 시:
  - `firstIndex(of:)`: 크기가 4인 고정 배열 탐색 → O(1)
  - 좌표 계산 및 범위 비교: O(1)
  - 조건 만족 시 좌표 대입: O(1)

따라서 최종적으로 **전체 시간 복잡도는 O(N)** 으로, 입력 명령 수에 따라 선형적으로 증가하며 효율적인 구현이라 할 수 있다.

이처럼 직접 구현한 로직도 각 단계별로 연산 수를 따져보면 시간 제한을 충분히 만족할 수 있음을 확인할 수 있다.


### ✅ 실제 풀이 예시 (Swift)

```swift
func getDestination(n: Int, plans: [String]) -> String {
    var x = 1
    var y = 1
    
    let dx = [0, 0, -1, 1]    // 행 이동: L, R, U, D
    let dy = [-1, 1, 0, 0]    // 열 이동
    let moveTypes = ["L", "R", "U", "D"]
    
    for plan in plans {
        if let i = moveTypes.firstIndex(of: plan) {
            let nx = x + dx[i]
            let ny = y + dy[i]
            
            // 범위를 벗어나는 경우 무시
            if nx >= 1 && ny >= 1 && nx <= n && ny <= n {
                x = nx
                y = ny
            }
        }
    }
    
    return "\(x) \(y)"
}

// 예시 입력
let result = getDestination(n: 5, plans: ["R", "R", "R", "U", "D", "D"])
print(result)  // 출력: 3 4
```

- 이 구현은 말코딩 흐름을 그대로 코드로 옮긴 예시이며, 가독성과 안정성도 우수하다.
- 범위 검사, 좌표 계산, 문자열 리턴까지 모두 Swift 문법에 익숙해지기에 좋은 연습 사례다.





## 🚶 구현 예제 2 - 시각

**문제 설명**

정수 N이 입력되면 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중에서  
**'3'이 하나라도 포함되는 모든 경우의 수**를 구하는 프로그램을 작성하시오.

예를 들어, 1을 입력했을 때 다음은 3이 하나라도 포함되므로 세어야 하는 시각이다:

- 00시 00분 03초
- 00시 13분 30초

반면 다음은 3이 하나도 포함되어 있지 않으므로 제외된다:

- 00시 02분 55초
- 01시 27분 45초

### 입력 조건

- 첫째 줄에 정수 N이 입력된다. (0 ≤ N ≤ 23)

### 출력 조건

- 00시 00분 00초부터 N시 59분 59초까지의 모든 시각 중  
  '3'이 하나라도 포함되는 경우의 수를 출력한다.

### 입력 예시

```
5
```

### 출력 예시

```
475
```

### 접근 방식

- 시(hour), 분(minute), 초(second)를 각각 포문으로 돌려서,  
  문자열에 '3'이 포함되는지를 확인하면 된다.
  
- 총 반복 횟수는 최대 24 * 60 * 60 = 86,400회로  
  시간 제한 내에 충분히 수행 가능하다.

### 💬 말코딩으로 살펴보는 구현 흐름

```swift
// - 시(hour) 0...N
// - 분(minute) 0..<60
// - 초(second) 0..<60
// - 세 수를 문자열로 만들어 "3"이 포함되는지 확인
// - 포함되어 있으면 count += 1
```

### ⏱ 시간 복잡도 분석

- hour 반복: N + 1회 (0부터 N까지)
- minute 반복: 60회
- second 반복: 60회

총 반복 횟수 = (N + 1) × 60 × 60  
= 최대 24 × 60 × 60 = **86,400번** (N = 23일 경우)

→ 문자열 변환 및 `.contains("3")`는 O(1) 상수 시간 내 처리되므로,  
→ 최종 시간 복잡도는 **O(N)** 이며, 매우 효율적이다.

※ 일반적인 코딩 테스트 환경에서 1억 회 이하 연산은 1초 내에 처리 가능하므로,  
이 구현은 시간 제한을 충분히 만족한다.

---

### 🧠 직접 풀면서 생각한 흐름

```swift
// 결과 : 경우의 갯수
//  00000 - N5959 까지 중에 3이 하나라도 있는 경우의 수

// 시, 분, 초에 3이 포함되어 있으면 count += 1

// 처음에는 패턴으로 가능할지 시도:
// 예: 0003, 0030, 0300, 3000, 3300 ...
// → 몇 개의 고정 패턴으로 15번 정도만 체크하면 될까? 라고 생각

// ❌ 하지만 실제로는 조합이 매우 많고 예외가 생김 (패턴화 실패)

// → 그래서 완전탐색으로 방향 전환

// 3중 포문 사용: 0시 0분 0초 ~ N시 59분 59초
// - 각 시간 문자열로 변환하고 contains("3") 포함 여부 확인
// - 포함되면 count += 1

// 완전탐색을 하더라도 최대 연산 수는 86,400 → 시간 복잡도 O(N), 충분히 가능
```

### 🧪 테스트 코드

```swift
func getCount(N: Int) -> Int {
    var count = 0
    
    for hour in 0...N {
        for minute in 0..<60 {
            for second in 0..<60 {
                let timeString = "\(hour)\(minute)\(second)"
                if timeString.contains("3") {
                    count += 1
                }
            }
        }
    }
    
    return count
}

print(getCount(N: 5))  // 👉 출력: 11475
```

---

