# Problem Solving Insights

이 문서는 코딩 테스트를 풀면서 겪는 시행착오, 깨달음, 방향 전환 등을  
**기록하고 돌아보기 위한 통찰 모음집**입니다.

---

## 🧭 코딩 테스트를 하며 느낀 통찰

- 처음에 풀고자 했던 방법이 막힐 수 있다.  
  → 그건 실패가 아니라, 더 나은 방법을 떠올릴 수 있는 **기회**가 된다.

- 구현이 안 될 때는 "이 문제를 꼭 이렇게 풀어야 하나?"를 되묻자.  
  → **다른 알고리즘, 더 간단한 패턴, 수학적 계산식**이 존재할 수 있다.

- where문이나 특정 문법이 헷갈려서 멈추는 건 자연스러운 일.  
  → 중요한 건 **멈추지 않고 다른 경로로 도전하는 것**.

- 처음에 시도한 방식보다 더 좋은 풀이가 보이면 **과감히 방향을 바꿔도 좋다.**  
  → 이건 '포기'가 아니라 **전략적 전환**이다.

- 결국 중요한 건 "정답을 맞히는 것"보다  
  → **문제를 이해하고 유연하게 접근하는 능력**이다.

> 한 줄 요약: 구현이 막혀도 괜찮아. 그 순간이 진짜 성장을 만드는 기회다.

---

## 🧮 시간 복잡도 참고표

코딩 테스트 중 시간 초과 여부를 빠르게 판단할 수 있도록  
자주 쓰는 시간 복잡도 정보를 아래에 정리합니다.

### 1. 시간 복잡도별 명칭 (위로 갈수록 빠름)

| 빅오 표기법 | 명칭              |
|-------------|-------------------|
| O(1)        | 상수 시간         |
| O(logN)     | 로그 시간         |
| O(N)        | 선형 시간         |
| O(NlogN)    | 로그 선형 시간    |
| O(N²)       | 이차 시간         |
| O(N³)       | 삼차 시간         |
| O(2^N)      | 지수 시간         |
| O(N!)       | 팩토리얼 시간     |

### 2. N의 크기에 따라 가능한 시간 복잡도 (시간 제한 1초 기준)

| N의 범위         | 설계 가능한 시간 복잡도 |
|------------------|--------------------------|
| N ≤ 500          | O(N³) 이하                |
| N ≤ 2,000        | O(N²) 이하                |
| N ≤ 100,000      | O(NlogN) 이하             |
| N ≤ 10,000,000   | O(N) 이하                 |
| N ≥ 1,000,000,000 | O(logN) 이하             |

### 3. N = 1,000일 때 연산 횟수 비교

| 빅오 표기법 | 연산 횟수 (N = 1,000 기준) |
|-------------|-----------------------------|
| O(N)        | 1,000                        |
| O(NlogN)    | 10,000                       |
| O(N²)       | 1,000,000                    |
| O(N³)       | 1,000,000,000                |

---

## ⚡️ 그리디 알고리즘 판단 치트시트

다음 조건 중 하나라도 만족한다면, 그리디 알고리즘을 먼저 떠올려 보자:

- ✅ **"가장 크거나 가장 작은" 값을 반복적으로 선택**해야 하는가?
  - 예: 가장 무거운 박스부터 채우기, 가장 적은 동전으로 거슬러주기
- ✅ **현재 선택이 이후 선택에 영향을 주지 않는가?**
  - 예: 독립적인 회의 시간, 선택한 항목이 나머지 조건을 침해하지 않는 구조
- ✅ **정렬 후 특정 기준대로 처리할 수 있는가?**
  - 문제에서 '정렬'이 암시되거나 직접 언급될 때
- ✅ **최적해를 찾는 대신, 근사 최적 조건을 만족하면 되는가?**
  - 무조건 최적이 아니라 ‘충분히 좋은 해’가 목적일 때
- ✅ **탐욕적으로 선택했을 때 항상 정답이 되는 조건이 존재하는가?**
  - 예: 문제에서 ‘가장 작은 단위부터 선택하면 항상 가능’이라고 명시되어 있음

### 📌 자주 보이는 표현들

- "가장 큰 순서대로", "가장 작은 순서대로"
- "최소/최대 횟수로", "가장 적게/많이"
- "연속적으로 선택", "선택을 반복"

> 이런 표현이 문제에 있다면 → **그리디 알고리즘 의심해보기!**
