# Problem Solving Insights

이 문서는 코딩 테스트를 풀면서 겪는 시행착오, 깨달음, 방향 전환 등을  
**기록하고 돌아보기 위한 통찰 모음집**입니다.

---

## 🧭 코딩 테스트를 하며 느낀 통찰

- 처음에 풀고자 했던 방법이 막힐 수 있다.  
  → 그건 실패가 아니라, 더 나은 방법을 떠올릴 수 있는 **기회**가 된다.

- 구현이 안 될 때는 "이 문제를 꼭 이렇게 풀어야 하나?"를 되묻자.  
  → **다른 알고리즘, 더 간단한 패턴, 수학적 계산식**이 존재할 수 있다.

- where문이나 특정 문법이 헷갈려서 멈추는 건 자연스러운 일.  
  → 중요한 건 **멈추지 않고 다른 경로로 도전하는 것**.

- 처음에 시도한 방식보다 더 좋은 풀이가 보이면 **과감히 방향을 바꿔도 좋다.**  
  → 이건 '포기'가 아니라 **전략적 전환**이다.

- 결국 중요한 건 "정답을 맞히는 것"보다  
  → **문제를 이해하고 유연하게 접근하는 능력**이다.

> 한 줄 요약: 구현이 막혀도 괜찮아. 그 순간이 진짜 성장을 만드는 기회다.

---

## 🧮 시간 복잡도 참고표

코딩 테스트 중 시간 초과 여부를 빠르게 판단할 수 있도록  
자주 쓰는 시간 복잡도 정보를 아래에 정리합니다.

### 1. 시간 복잡도별 명칭 (위로 갈수록 빠름)

| 빅오 표기법 | 명칭              |
|-------------|-------------------|
| O(1)        | 상수 시간         |
| O(logN)     | 로그 시간         |
| O(N)        | 선형 시간         |
| O(NlogN)    | 로그 선형 시간    |
| O(N²)       | 이차 시간         |
| O(N³)       | 삼차 시간         |
| O(2^N)      | 지수 시간         |
| O(N!)       | 팩토리얼 시간     |

### 2. N의 크기에 따라 가능한 시간 복잡도 (시간 제한 1초 기준)

| N의 범위         | 설계 가능한 시간 복잡도 |
|------------------|--------------------------|
| N ≤ 500          | O(N³) 이하                |
| N ≤ 2,000        | O(N²) 이하                |
| N ≤ 100,000      | O(NlogN) 이하             |
| N ≤ 10,000,000   | O(N) 이하                 |
| N ≥ 1,000,000,000 | O(logN) 이하             |

### 3. N = 1,000일 때 연산 횟수 비교

| 빅오 표기법 | 연산 횟수 (N = 1,000 기준) |
|-------------|-----------------------------|
| O(N)        | 1,000                        |
| O(NlogN)    | 10,000                       |
| O(N²)       | 1,000,000                    |
| O(N³)       | 1,000,000,000                |

---

## ⚡️ 그리디 알고리즘 판단 치트시트

다음 조건 중 하나라도 만족한다면, 그리디 알고리즘을 먼저 떠올려 보자:

- ✅ **"가장 크거나 가장 작은" 값을 반복적으로 선택**해야 하는가?
  - 예: 가장 무거운 박스부터 채우기, 가장 적은 동전으로 거슬러주기
- ✅ **현재 선택이 이후 선택에 영향을 주지 않는가?**
  - 예: 독립적인 회의 시간, 선택한 항목이 나머지 조건을 침해하지 않는 구조
- ✅ **정렬 후 특정 기준대로 처리할 수 있는가?**
  - 문제에서 '정렬'이 암시되거나 직접 언급될 때
- ✅ **최적해를 찾는 대신, 근사 최적 조건을 만족하면 되는가?**
  - 무조건 최적이 아니라 ‘충분히 좋은 해’가 목적일 때
- ✅ **탐욕적으로 선택했을 때 항상 정답이 되는 조건이 존재하는가?**
  - 예: 문제에서 ‘가장 작은 단위부터 선택하면 항상 가능’이라고 명시되어 있음

### 📌 자주 보이는 표현들

- "가장 큰 순서대로", "가장 작은 순서대로"
- "최소/최대 횟수로", "가장 적게/많이"
- "연속적으로 선택", "선택을 반복"

> 이런 표현이 문제에 있다면 → **그리디 알고리즘 의심해보기!**

## 그래프 탐색 
### 상하좌우 탐색
- 방향정의
- 지도정의 (범위체크)

상하좌우 탐색 문제에서는 보통 아래와 같이 **dx, dy 배열**을 선언하여 각 방향으로의 이동을 표현한다.

```swift
let dx = [0, 0, -1, 1]
let dy = [-1, 1, 0, 0]
```


지도가 있는 경우 범위를 넘어가면안되는 조건이 붙는다. 
마지막에 해당 조건이 들어가야한다. 
```swift
if nx >= 1 && ny >=1 && nx <= n && ny <= n {
    // 조건처리
}
```

### 정해진 방향대로 가야하는 경우

- 방향정의
- (!!) + 정해진 방향 타입 정의
- 지도정의 (범위체크)


이때에는 정해진 방향이 제시될 것이다. 
이때 방향과 index를 동일하게 매핑해야한다.

```swift
let dx = [0, 0, -1, 1]
let dy = [-1, 1, 0, 0]
let moveTypes = ["L", "R", "U", "D"]
```


여기서 중요한 점은 배열의 순서가 서로 정확히 매핑되어야 한다는 것이다.
- 예를 들어, moveTypes[0]가 "L"이라면, dx[0]와 dy[0]는 각각 왼쪽 이동을 의미해야 한다.


## 방문체크를 고려하는 경우
- 방향정의
- 지도정의 (범위체크)
- 방문체크

이때에는 정해진 방향보다는 네 방향을 전부 체크해서 가지않은 곳에 가는 경우를 체크하는 경우다.

```swift
var visited = Array(repeating: Array(repeating: false, count: m), count: n)

if !visited[nx][ny] {
    visited[nx][ny] = true
    // 로직 수행
}
```


여기에 지도 범위까지 고려하면 아래와 같이 될 것이다. 

```swift
var visited = Array(repeating: Array(repeating: false, count: m), count: n)

for i in 0..<4 {
    let nx = x + dx[i]
    let ny = y + dy[i]

    if nx >= 0 && ny >= 0 && nx < n && ny < m && !visited[nx][ny] {
        visited[nx][ny] = true
        // 로직 수행 (예: dfs(nx, ny))
    }
}
```

## ⚡️ 그래프 탐색 판단 치트시트

다음 조건 중 하나라도 만족한다면, 그래프 탐색 (DFS / BFS)을 우선적으로 떠올려 보자:

- ✅ “이동”, “탐색”, “연결”이라는 키워드가 나오는가?
    - 예: 특정 위치에서 상하좌우로 이동, 특정 노드끼리 연결되어 있음
- ✅ 문제가 2차원 배열(지도)나 노드-간 연결 구조로 주어지는가?
    - 예: N x M 격자, 연결 리스트, 인접 행렬, 간선 리스트
- ✅ 방문 여부(visited)를 체크해야 할 것 같은 조건이 있는가?
    - 예: 한 번 간 곳은 다시 가지 않음, 사이클 탐지, 영역 개수 세기 등
- ✅ 모든 경우의 수를 살펴보거나, 연결된 덩어리(영역)를 나누어야 하는가?
    - 예: 미로 탈출, 섬의 개수, 영역 채우기, 바이러스 전파
- ✅ 최단 거리, 최소 이동 횟수 등이 키워드로 주어졌는가?
    - BFS가 자동으로 최단 경로를 찾는 특성 덕분에 이런 조건일 땐 거의 BFS

### 📌 자주 보이는 표현들
- “인접한 곳으로 이동”, “네 방향 이동”, “연결되어 있다”
- “영역의 수를 구하라”, “최소 몇 번 만에 도달”
- “모든 칸을 방문”, “더 이상 이동할 수 없을 때까지”
- “방문 여부를 체크하며 반복”

> 이런 표현이 문제에 있다면 → 그래프 탐색 (DFS/BFS) 문제일 가능성 높음!


